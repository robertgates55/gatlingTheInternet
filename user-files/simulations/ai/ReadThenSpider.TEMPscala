package ai

import io.gatling.core.Predef._
import io.gatling.core.session.Expression
import io.gatling.core.structure.ChainBuilder
import io.gatling.http.Predef._
import io.gatling.http.check.HttpCheck

import scala.concurrent.duration._

class ReadThenSpider extends Simulation {

  object Spider {

    val feeder = csv("urlsUS.csv").random

    val noProxy = chain("[D]_UA-1_http")
    val withProxy = chain("[P]_UA-1_http")

    def extractLink(): HttpCheck = {
      css("a","href")
      //  regex( """<a [^>]*href="([^#"]+)""")
          .findAll
          .transform(s => util.Random.shuffle(s).head)
          .optional
          .saveAs("link")
    }

    def getCheckPause(actionName: String, url : String): ChainBuilder = {
      exec(http(actionName).get(url).check(extractLink)).pause(5 seconds)
    }

    def chain(actionName: String): ChainBuilder = {
      feed(feeder)
        .exec(getCheckPause(actionName, "http://${url}"))
        .doIf(session => session("link").asOption[Any].isDefined) {
          repeat(util.Random.nextInt(10).toInt) {
            doIfOrElse(session => session("link").as[String].matches( "https?://.*")) {
              // link = http(s)://something
              getCheckPause(actionName, "${link}")
            } {
              // else
              doIfOrElse(session => session("link").as[String].startsWith("/")) {
                // link starts with / or //
                doIfOrElse(session => session("link").as[String].startsWith("//")) {
                  // link = //something
                  getCheckPause(actionName, "http:${link}")
                } {
                  // else presume link = /something
                  getCheckPause(actionName, "http://${url}${link}")
                }
              } {
                // else link = not /, //, http or https...
                getCheckPause(actionName, "http://${url}/${link}")
              }
            }
          }
        }
    }
  }

  def randomUA: Expression[String] = {
    s => UAs.userAgents.get(util.Random.nextInt(UAs.userAgents.length))
  }

  val httpNoProxyConf = http
    .acceptHeader("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    .doNotTrackHeader("1")
    .acceptLanguageHeader("en-US,en;q=0.5")
    .acceptEncodingHeader("gzip, deflate")
    .userAgentHeader(randomUA)
    .inferHtmlResources
    .silentResources
    .disableCaching
    .disableAutoReferer
    .maxConnectionsPerHostLikeChrome
    .maxRedirects(5)

  val httpWithProxyConf = httpNoProxyConf
  .proxy(Proxy("proxy.qa.streamshield.net", 3128).httpsPort(3128))

  val usersNoProxy = scenario("Users No proxy").exec(Spider.noProxy)
  val usersWithProxy = scenario("Users with proxy").exec(Spider.withProxy)

  // test run config
  val testDuration = 8 hours
  val maxUserCount = 125
  val meanUserLife = 600 // seconds
  val numberToInjectOverDuration = ((math.ceil(testDuration.toSeconds) * maxUserCount) / meanUserLife).toInt //hoping test duration is in seconds

  setUp(
    usersWithProxy
      .inject(
        rampUsers(math.ceil(numberToInjectOverDuration).toInt) over testDuration)
      .protocols(httpWithProxyConf)
    ,
     usersNoProxy
       .inject(
         rampUsers(math.ceil(numberToInjectOverDuration * 0.05).toInt) over testDuration)
       .protocols(httpNoProxyConf)
  ).maxDuration(testDuration)


}
